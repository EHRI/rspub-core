

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>rspub.util.gates &mdash; rspub-core 1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="rspub-core 1 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> rspub-core
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../rst/rspub.cli.html">rspub.cli</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rst/rspub.core.html">rspub.core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rst/rspub.pluggable.html">rspub.pluggable</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rst/rspub.util.html">rspub.util</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../index.html">rspub-core</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      
    <li>rspub.util.gates</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for rspub.util.gates</h1><div class="highlight"><pre>
<span></span><span class="ch">#! /usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">:samp:`Logical functions, gate and gate builders`</span>


<span class="sd">Logical functions</span>
<span class="sd">-----------------</span>

<span class="sd">Each logical function takes a one-argument predicate or a list of one-argument predicates. In turn</span>
<span class="sd">each logical function returns a one-argument predicate that is the chain of, or the negation of its arguments.</span>
<span class="sd">There are functions to chain predicates along</span>
<span class="sd">:func:`not_`, :func:`and_`, :func:`or_`, :func:`nand_`, :func:`nor_`, :func:`xor_` and :func:`xnor_`.</span>

<span class="sd">Each logical function, before returning the chained predicate, will check if the predicates in the argument list</span>
<span class="sd">are truly one-argument predicates. The behavior after detection of a wrong argument can be set</span>
<span class="sd">by the module-method :func:`set_stop_on_creation_error`.</span>
<span class="sd">The default behavior after detection of a wrong argument is to throw a :exc:`GateCreationException`.</span>

<span class="sd">**Example usage**</span>

<span class="sd">Given closures or lambda&#39;s::</span>

<span class="sd">    &gt;&gt;&gt; spam = lambda word : word.startswith(&quot;spam&quot;)</span>
<span class="sd">    &gt;&gt;&gt; eggs = lambda word: word.endswith(&quot;eggs&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ampersand = lambda word: len(word.split(&quot;&amp;&quot;)) &gt; 1</span>

<span class="sd">Now you can create a test for spam &amp; eggs::</span>

<span class="sd">    &gt;&gt;&gt; from rspub.util.gates import and_</span>
<span class="sd">    &gt;&gt;&gt; spam_and_eggs = and_(spam, eggs, ampersand)</span>

<span class="sd">and reuse `spam` and `eggs` to create spam nor eggs::</span>

<span class="sd">    &gt;&gt;&gt; from rspub.util.gates import nor_</span>
<span class="sd">    &gt;&gt;&gt; spam_nor_eggs = nor_(spam, eggs)</span>

<span class="sd">and use the assembled predicates::</span>

<span class="sd">    &gt;&gt;&gt; spam_and_eggs(&quot;spam &amp; eggs&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; spam_and_eggs(&quot;spamming leggs&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; spam_nor_eggs(&quot;bacon&quot;)</span>
<span class="sd">    True</span>

<span class="sd">Of course your closures and lambda&#39;s all need to be able to handle the type of argument given.</span>

<span class="sd">Gate</span>
<span class="sd">----</span>

<span class="sd">The function :func:`gate` takes two lists of predicates, *includes* and *excludes*.</span>
<span class="sd">Includes is the list of predicates that can</span>
<span class="sd">permit `x` through the gate; excludes is the list of predicates that can prevent `x` from passing the gate.</span>

<span class="sd">Building gates</span>
<span class="sd">--------------</span>

<span class="sd">The abstract class :class:`GateBuilder` defines the methods to construct a GateBuilder. The concrete class</span>
<span class="sd">:class:`PluggedInGateBuilder` walks zero or more plugin directories looking for specifically named builders</span>
<span class="sd">in order to build a customized :func:`gate`.</span>

<span class="sd">If :class:`GateBuilder` s are chained, a builder can overrule `includes` and `excludes` from previous builders.</span>

<span class="sd">-------</span>

<span class="sd">Classes and functions</span>
<span class="sd">---------------------</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="k">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">takewhile</span>
<span class="kn">import</span> <span class="nn">rspub.util.plugg</span> <span class="k">as</span> <span class="nn">plugg</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;not_&#39;</span><span class="p">,</span> <span class="s1">&#39;and_&#39;</span><span class="p">,</span> <span class="s1">&#39;or_&#39;</span><span class="p">,</span> <span class="s1">&#39;nand_&#39;</span><span class="p">,</span> <span class="s1">&#39;nor_&#39;</span><span class="p">,</span> <span class="s1">&#39;xor_&#39;</span><span class="p">,</span> <span class="s1">&#39;xnor_&#39;</span><span class="p">,</span> <span class="s1">&#39;gate&#39;</span><span class="p">,</span>
           <span class="s1">&#39;GateBuilder&#39;</span><span class="p">,</span> <span class="s1">&#39;PluggedInGateBuilder&#39;</span><span class="p">,</span> <span class="s1">&#39;GateCreationException&#39;</span><span class="p">,</span> <span class="s1">&#39;GateBuilderException&#39;</span><span class="p">,</span>
           <span class="s1">&#39;is_one_arg_predicate&#39;</span><span class="p">,</span> <span class="s1">&#39;set_stop_on_creation_error&#39;</span><span class="p">,</span> <span class="s1">&#39;stop_on_creation_error&#39;</span><span class="p">]</span>

<span class="n">LOG</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="not_"><a class="viewcode-back" href="../../../rst/rspub.util.gates.html#rspub.util.gates.not_">[docs]</a><span class="k">def</span> <span class="nf">not_</span><span class="p">(</span><span class="n">predicate</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :samp:`Creates the negation of the given {predicate}`</span>

<span class="sd">    The outcome of a `not_   f` for any `x` is::</span>

<span class="sd">        f(x) = not p(x)</span>

<span class="sd">    where `p` is the given predicate.</span>

<span class="sd">    :param predicate: the predicate to negate</span>
<span class="sd">    :return: a new predicate implementing the negation of the given predicate</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_one_arg_predicate</span><span class="p">(</span><span class="n">predicate</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="ow">not</span> <span class="n">predicate</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="and_"><a class="viewcode-back" href="../../../rst/rspub.util.gates.html#rspub.util.gates.and_">[docs]</a><span class="k">def</span> <span class="nf">and_</span><span class="p">(</span><span class="o">*</span><span class="n">predicates</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :samp:`Creates the logical conjunction of the given {predicates}`</span>

<span class="sd">    Chains `predicates` in `and`. The outcome of an `and_  f` for any `x` is::</span>

<span class="sd">        f(x) = p_1(x) and p_2(x) and ... and p_n(x)</span>

<span class="sd">    where `p_1 ... p_n` are the given predicates.</span>

<span class="sd">    The chain of predicates is **True** if all predicates are **True**, otherwise **False**.</span>
<span class="sd">    Outcome **True** in effect says that all of the predicates evaluated as **True**.</span>

<span class="sd">    Logical performance has been optimized. i.e. `A and B and C` is **False** if `A` evaluates as **False**;</span>
<span class="sd">    do not test `B` and `C` in this case.</span>

<span class="sd">    :param predicates: predicates to chain in and.</span>
<span class="sd">    :return: a new predicate implementing the combined `and` of the given predicates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ps</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">predicates</span> <span class="k">if</span> <span class="n">is_one_arg_predicate</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">takewhile</span><span class="p">(</span><span class="k">lambda</span> <span class="n">predicate</span><span class="p">:</span> <span class="n">predicate</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">ps</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span></div>


<div class="viewcode-block" id="nor_"><a class="viewcode-back" href="../../../rst/rspub.util.gates.html#rspub.util.gates.nor_">[docs]</a><span class="k">def</span> <span class="nf">nor_</span><span class="p">(</span><span class="o">*</span><span class="n">predicates</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :samp:`Creates the joint denial of the given {predicates}`</span>

<span class="sd">    Chains `predicates` in `nor`. The outcome of a `nor_  f` for any `x` is::</span>

<span class="sd">        f(x) = not(p_1(x) or p_2(x) or ... or p_n(x))</span>

<span class="sd">    where `p_1 ... p_n` are the given predicates.</span>

<span class="sd">    The chain of predicates is **False** if at least one predicate is **True**, otherwise **True**.</span>
<span class="sd">    Outcome **True** in effect says that neither one of the predicates evaluated as **True**.</span>

<span class="sd">    Logical performance has been optimized. i.e. `A nor B nor C` is **False** if `A` evaluates as **True**;</span>
<span class="sd">    do not test `B` and `C` in this case.</span>

<span class="sd">    :param predicates: predicates to chain in nor.</span>
<span class="sd">    :return: a new predicate implementing the combined `nor` of the given predicates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ps</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">predicates</span> <span class="k">if</span> <span class="n">is_one_arg_predicate</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">takewhile</span><span class="p">(</span><span class="k">lambda</span> <span class="n">predicate</span><span class="p">:</span> <span class="ow">not</span> <span class="n">predicate</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">ps</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span></div>


<div class="viewcode-block" id="or_"><a class="viewcode-back" href="../../../rst/rspub.util.gates.html#rspub.util.gates.or_">[docs]</a><span class="k">def</span> <span class="nf">or_</span><span class="p">(</span><span class="o">*</span><span class="n">predicates</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :samp:`Creates the logical inclusive disjunction of the given {predicates}`</span>

<span class="sd">    Chains `predicates` in `or`. The outcome of an `or_  f` for any `x` is::</span>

<span class="sd">        f(x) = p_1(x) or p_2(x) or ... or p_n(x)</span>

<span class="sd">    where `p_1 ... p_n` are the given predicates.</span>

<span class="sd">    The chain of predicates is **True** if at least one predicate is **True**, otherwise **False**.</span>
<span class="sd">    Outcome **True** in effect says that at least one of the predicates evaluated as **True**.</span>

<span class="sd">    Logical performance has been optimized. i.e. `A or B or C` is **True** if `A` evaluates as **True**;</span>
<span class="sd">    do not test `B` and `C` in this case.</span>

<span class="sd">    :param predicates: predicates to chain in or.</span>
<span class="sd">    :return: a new predicate implementing the combined `or` of the given predicates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">not_</span><span class="p">(</span><span class="n">nor_</span><span class="p">(</span><span class="o">*</span><span class="n">predicates</span><span class="p">))</span></div>


<div class="viewcode-block" id="nand_"><a class="viewcode-back" href="../../../rst/rspub.util.gates.html#rspub.util.gates.nand_">[docs]</a><span class="k">def</span> <span class="nf">nand_</span><span class="p">(</span><span class="o">*</span><span class="n">predicates</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :samp:`Creates the alternative denial of the given {predicates}`</span>

<span class="sd">    Chains `predicates` in `nand`. The outcome of a `nand_  f` for any `x` is::</span>

<span class="sd">        f(x) = not(p_1(x) and p_2(x) and ... and p_n(x))</span>

<span class="sd">    where `p_1 ... p_n` are the given predicates.</span>

<span class="sd">    The chain of predicates is **False** if all predicates are **True**, otherwise **True**.</span>
<span class="sd">    Outcome **True** in effect says that at least one of the predicates evaluated as **False**.</span>

<span class="sd">    Logical performance has been optimized. i.e. `A nand B nand C` is **True** if `A` evaluates as **False**;</span>
<span class="sd">    do not test `B` and `C` in this case.</span>

<span class="sd">    :param predicates: predicates to chain in nand.</span>
<span class="sd">    :return: a new predicate implementing the combined `nand` of the given predicates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">not_</span><span class="p">(</span><span class="n">and_</span><span class="p">(</span><span class="o">*</span><span class="n">predicates</span><span class="p">))</span></div>


<div class="viewcode-block" id="xor_"><a class="viewcode-back" href="../../../rst/rspub.util.gates.html#rspub.util.gates.xor_">[docs]</a><span class="k">def</span> <span class="nf">xor_</span><span class="p">(</span><span class="o">*</span><span class="n">predicates</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :samp:`Creates the exclusive disjunction of the given {predicates}`</span>

<span class="sd">    Chains `predicates` in `xor`. The outcome of an `xor_  f` for any `x` is::</span>

<span class="sd">            f(x) = p_1(x) xor p_2(x) xor ... xor p_n(x)</span>

<span class="sd">    where `p_1 ... p_n` are the given predicates.</span>

<span class="sd">    One definition of xor says:</span>
<span class="sd">    &quot;A chain of XORs—a XOR b XOR c XOR d (and so on)—is true whenever an odd number</span>
<span class="sd">    of the inputs are true and is false whenever an even number of inputs are true.</span>
<span class="sd">    https://en.wikipedia.org/wiki/Exclusive_or</span>

<span class="sd">    Some definitions even deny that there can be more than two inputs:</span>
<span class="sd">    &quot;a Boolean operator working on two variables that has the value one if one</span>
<span class="sd">    but not both of the variables is one&quot;.</span>
<span class="sd">    https://www.google.nl/search?q=define+exclusive+OR</span>

<span class="sd">    However, this implementation adheres to:</span>

<span class="sd">    The chain of predicates is **True** if one and only one predicate is **True**, otherwise **False**.</span>

<span class="sd">    :param predicates: predicates to chain with xor.</span>
<span class="sd">    :return: a new predicate implementing the combined `xor` of the given predicates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ps</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">predicates</span> <span class="k">if</span> <span class="n">is_one_arg_predicate</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">predicate</span> <span class="ow">in</span> <span class="n">ps</span> <span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">x</span><span class="p">)])</span> <span class="o">==</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="xnor_"><a class="viewcode-back" href="../../../rst/rspub.util.gates.html#rspub.util.gates.xnor_">[docs]</a><span class="k">def</span> <span class="nf">xnor_</span><span class="p">(</span><span class="o">*</span><span class="n">predicates</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :samp:`Creates the logical equality of the given {predicates}`</span>

<span class="sd">    Chains `predicates` in `xnor`. The outcome of an `xnor_  f` for any `x` is::</span>

<span class="sd">        f(x) = (p_1(x) and p_2(x) and ... and p_n(x)) or not(p_1(x) or p_2(x) or ... or p_n(x))</span>

<span class="sd">    where `p_1 ... p_n` are the given predicates.</span>

<span class="sd">    The chain of predicates is **True** if *all* predicates evaluate as **True** or *all* predicates</span>
<span class="sd">    evaluate as **False**.</span>
<span class="sd">    (So this is *not* the negation of xor as implemented above.)</span>

<span class="sd">    :param predicates: predicates to chain with xnor.</span>
<span class="sd">    :return: a new predicate implementing the combined `xnor` of the given predicates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ps</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">predicates</span> <span class="k">if</span> <span class="n">is_one_arg_predicate</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">_xnor</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">predicate</span> <span class="ow">in</span> <span class="n">ps</span> <span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">x</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">count</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_xnor</span></div>


<div class="viewcode-block" id="gate"><a class="viewcode-back" href="../../../rst/rspub.util.gates.html#rspub.util.gates.gate">[docs]</a><span class="k">def</span> <span class="nf">gate</span><span class="p">(</span><span class="n">includes</span><span class="o">=</span><span class="nb">list</span><span class="p">(),</span> <span class="n">excludes</span><span class="o">=</span><span class="nb">list</span><span class="p">()):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :samp:`Creates the logical conjunction of or_({includes}), nor_({excludes})`</span>

<span class="sd">    Chains `including` predicates and `excluding` predicates. The outcome of a gate `g` for any `x` is::</span>

<span class="sd">        g(x) = (i_1(x) or i_2(x) or ... or i_n(x)) and not(e_1(x) or e_2(x) or ... or e_n(x))</span>

<span class="sd">    where `i_1 ... i_n` are given including predicates and `e_1 ... e_n` are given excluding predicates.</span>

<span class="sd">    The gate evaluates as **True** if at least one of `includes` is **True** and none of `excludes` are **True**.</span>

<span class="sd">    :param list includes: predicates that permit `x` through gate</span>
<span class="sd">    :param list excludes: predicates that restrict `x` from gate</span>
<span class="sd">    :return: a new predicate implementing the combined functions given in `includes` and `excludes`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">and_</span><span class="p">(</span><span class="n">or_</span><span class="p">(</span><span class="o">*</span><span class="n">includes</span><span class="p">),</span> <span class="n">nor_</span><span class="p">(</span><span class="o">*</span><span class="n">excludes</span><span class="p">))</span></div>


<div class="viewcode-block" id="GateBuilder"><a class="viewcode-back" href="../../../rst/rspub.util.gates.html#rspub.util.gates.GateBuilder">[docs]</a><span class="k">class</span> <span class="nc">GateBuilder</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :samp:`Abstract builder class for gates`</span>

<span class="sd">    GateBuilders should extend this abstract class or</span>
<span class="sd">    implement the next two methods. In these methods GateBuilders are free to extend on previously defined</span>
<span class="sd">    lists of permitting and restricting predicates, remove elements from them or overrule previous steps</span>
<span class="sd">    and return complete new lists.</span>

<span class="sd">    .. seealso:: :func:`gate`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@abstractmethod</span>
<div class="viewcode-block" id="GateBuilder.build_includes"><a class="viewcode-back" href="../../../rst/rspub.util.gates.html#rspub.util.gates.GateBuilder.build_includes">[docs]</a>    <span class="k">def</span> <span class="nf">build_includes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">includes</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :samp:`Define the list of permitting predicates`</span>

<span class="sd">        Either rework the given list (append, extend, remove, replace),</span>
<span class="sd">        return the given list or return a complete new list.</span>
<span class="sd">        The returned list should consist of one-argument predicates.</span>

<span class="sd">        :param list includes: the list of permitting predicates (from previous builders)</span>
<span class="sd">        :return: the list of permitting predicates as defined by this GateBuilder</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">includes</span></div>

    <span class="nd">@abstractmethod</span>
<div class="viewcode-block" id="GateBuilder.build_excludes"><a class="viewcode-back" href="../../../rst/rspub.util.gates.html#rspub.util.gates.GateBuilder.build_excludes">[docs]</a>    <span class="k">def</span> <span class="nf">build_excludes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">excludes</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :samp:`Define the list of restricting predicates`</span>

<span class="sd">        Either rework the given list (append, extend, remove, replace),</span>
<span class="sd">        return the given list or return a complete new list.</span>
<span class="sd">        The returned list should consist of one-argument predicates.</span>

<span class="sd">        :param list excludes: the list of restricting predicates (from previous builders)</span>
<span class="sd">        :return: the list of restricting predicates as defined by this GateBuilder</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">excludes</span></div></div>


<div class="viewcode-block" id="PluggedInGateBuilder"><a class="viewcode-back" href="../../../rst/rspub.util.gates.html#rspub.util.gates.PluggedInGateBuilder">[docs]</a><span class="k">class</span> <span class="nc">PluggedInGateBuilder</span><span class="p">(</span><span class="n">GateBuilder</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :samp:`Builds pluggable {gates}`</span>

<span class="sd">    The PluggedInGateBuilder can be given zero or more directories where it will recursively look for</span>
<span class="sd">    GateBuilders of the given `builder_name`. It will then instantiate the builder and give it the opportunity to</span>
<span class="sd">    determine the list of including predicates and the list of excluding predicates as ``this`` builder calls</span>
<span class="sd">    :func:`~GateBuilder.build_includes` and :func:`~GateBuilder.build_excludes` on the plugged-in builder.</span>

<span class="sd">    A class in the given `plugin_directories` will qualify as builder if at least</span>

<span class="sd">    - it has a name equal to the given `builder_name` and</span>
<span class="sd">    - it is a subclass of :class:`GateBuilder` or it implements both methods of this class.</span>

<span class="sd">    The final :func:`gate` can be obtained by calling :func:`build_gate`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="PluggedInGateBuilder.__init__"><a class="viewcode-back" href="../../../rst/rspub.util.gates.html#rspub.util.gates.PluggedInGateBuilder.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">builder_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">first_builder</span><span class="p">:</span> <span class="n">GateBuilder</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">plugin_directories</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :samp:`Initialize a {PluggedInGateBuilder}`</span>

<span class="sd">        :param str builder_name: the class name (either simple or qualified) of the class implementing the GateBuilder methods.</span>
<span class="sd">        :param GateBuilder first_builder: builder of default or initial predicates, may be **None**</span>
<span class="sd">        :param str plugin_directories: the directories where to search for GateBuilders with the given builder_name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">builder_name</span> <span class="o">=</span> <span class="n">builder_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plugin_directories</span> <span class="o">=</span> <span class="n">plugin_directories</span>

        <span class="k">if</span> <span class="n">first_builder</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">includes</span> <span class="o">=</span> <span class="n">first_builder</span><span class="o">.</span><span class="n">build_includes</span><span class="p">(</span><span class="nb">list</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">excludes</span> <span class="o">=</span> <span class="n">first_builder</span><span class="o">.</span><span class="n">build_excludes</span><span class="p">(</span><span class="nb">list</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inspect_predicates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">includes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">excludes</span><span class="p">,</span> <span class="n">first_builder</span><span class="o">.</span><span class="n">__class__</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">includes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">excludes</span> <span class="o">=</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="PluggedInGateBuilder.build_includes"><a class="viewcode-back" href="../../../rst/rspub.util.gates.html#rspub.util.gates.PluggedInGateBuilder.build_includes">[docs]</a>    <span class="k">def</span> <span class="nf">build_includes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">includes</span><span class="o">=</span><span class="nb">list</span><span class="p">())</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :samp:`Set initial permitting predicates`</span>

<span class="sd">        :param list includes: the list of initial permitting predicates</span>
<span class="sd">        :return: the list of initial permitting predicates</span>
<span class="sd">        :raises: :exc:`GateCreationException` if a predicate was not a one-argument predicate</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">valid_includes</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">includes</span> <span class="k">if</span> <span class="n">is_one_arg_predicate</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">includes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">valid_includes</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">includes</span></div>

<div class="viewcode-block" id="PluggedInGateBuilder.build_excludes"><a class="viewcode-back" href="../../../rst/rspub.util.gates.html#rspub.util.gates.PluggedInGateBuilder.build_excludes">[docs]</a>    <span class="k">def</span> <span class="nf">build_excludes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">excludes</span><span class="o">=</span><span class="nb">list</span><span class="p">())</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :samp:`Set initial restricting predicates`</span>

<span class="sd">        :param list excludes: the list of initial restricting predicates</span>
<span class="sd">        :return: the list of initial restricting predicates</span>
<span class="sd">        :raises: :exc:`GateCreationException` if a predicate was not a one-argument predicate</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">valid_excludes</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">excludes</span> <span class="k">if</span> <span class="n">is_one_arg_predicate</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">excludes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">valid_excludes</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">excludes</span></div>

<div class="viewcode-block" id="PluggedInGateBuilder.build_gate"><a class="viewcode-back" href="../../../rst/rspub.util.gates.html#rspub.util.gates.PluggedInGateBuilder.build_gate">[docs]</a>    <span class="k">def</span> <span class="nf">build_gate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">gate</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :samp:`Build a gate as defined by found GateBuilders in {plugin_directories}`</span>

<span class="sd">        Found GateBuilders are given</span>
<span class="sd">        the chance to modify the lists `includes` and `excludes`.</span>
<span class="sd">        The initial lists `includes` and `excludes` are populated by predicates as defined by `first_builder`.</span>
<span class="sd">        If no `first_builder` was given, the initial lists will be empty lists.</span>

<span class="sd">        :return: :func:`gate` as defined by found GateBuilders.</span>
<span class="sd">        :raises: :exc:`GateCreationException` if a gate could not be created because a given value is not a one-argument predicate.</span>
<span class="sd">        :raises: :exc:`GateBuilderException` if a gate could not be built because of inappropriate behavior of a GateBuilder.</span>

<span class="sd">        .. seealso:: :func:`gate`, :class:`GateBuilder`, :func:`GateBuilder.build_includes`, :func:`GateBuilder.build_excludes`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_subclass</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">GateBuilder</span><span class="p">)</span>
        <span class="n">has_both_metods</span> <span class="o">=</span> <span class="n">and_</span><span class="p">(</span><span class="n">plugg</span><span class="o">.</span><span class="n">has_function</span><span class="p">(</span><span class="n">GateBuilder</span><span class="o">.</span><span class="n">build_includes</span><span class="o">.</span><span class="n">__name__</span><span class="p">),</span>
                               <span class="n">plugg</span><span class="o">.</span><span class="n">has_function</span><span class="p">(</span><span class="n">GateBuilder</span><span class="o">.</span><span class="n">build_excludes</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>
        <span class="n">has_builder_name</span> <span class="o">=</span> <span class="n">plugg</span><span class="o">.</span><span class="n">is_named</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">builder_name</span><span class="p">)</span>
        <span class="n">is_subclass_or_has_methods</span> <span class="o">=</span> <span class="n">or_</span><span class="p">(</span><span class="n">is_subclass</span><span class="p">,</span> <span class="n">has_both_metods</span><span class="p">)</span>
        <span class="n">builder_predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">and_</span><span class="p">(</span><span class="n">is_subclass_or_has_methods</span><span class="p">,</span> <span class="n">has_builder_name</span><span class="p">)]</span>

        <span class="n">inspector</span> <span class="o">=</span> <span class="n">plugg</span><span class="o">.</span><span class="n">Inspector</span><span class="p">(</span><span class="n">stop_on_error</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">cls</span> <span class="ow">in</span> <span class="n">inspector</span><span class="o">.</span><span class="n">list_classes_filtered</span><span class="p">(</span><span class="n">builder_predicates</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">plugin_directories</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isabstract</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">GateBuilderException</span><span class="p">(</span><span class="s2">&quot;GateBuilder cannot be instantiated: class is abstract: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">cls</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">builder</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
                    <span class="n">builder</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
                <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">GateBuilderException</span><span class="p">(</span><span class="s2">&quot;Could not instantiate object (</span><span class="si">%s</span><span class="s2"> in </span><span class="si">%s</span><span class="s2">)&quot;</span>
                                               <span class="o">%</span> <span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getfile</span><span class="p">(</span><span class="n">cls</span><span class="p">)))</span> <span class="kn">from</span> <span class="nn">exc</span>

                <span class="n">tmp_includes</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="n">build_includes</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">includes</span><span class="p">))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tmp_includes</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">GateBuilderException</span><span class="p">(</span><span class="s2">&quot;Illegal return value for build_includes: &quot;</span>
                                               <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> in stead of list. (</span><span class="si">%s</span><span class="s2"> in </span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">includes</span><span class="p">,</span> <span class="n">cls</span><span class="p">,</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getfile</span><span class="p">(</span><span class="n">cls</span><span class="p">)))</span>
                <span class="n">tmp_excludes</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="n">build_excludes</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">excludes</span><span class="p">))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tmp_excludes</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">GateBuilderException</span><span class="p">(</span><span class="s2">&quot;Illegal return value for build_excludes: &quot;</span>
                                               <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> in stead of list. (</span><span class="si">%s</span><span class="s2"> in </span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">excludes</span><span class="p">,</span> <span class="n">cls</span><span class="p">,</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getfile</span><span class="p">(</span><span class="n">cls</span><span class="p">)))</span>

                <span class="c1"># multiple inspects of same predicates are taking place during execution of this method,</span>
                <span class="c1"># but at least here we can pinpoint the culprit if any invalid.</span>
                <span class="n">valid_includes</span><span class="p">,</span> <span class="n">valid_excludes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inspect_predicates</span><span class="p">(</span><span class="n">tmp_includes</span><span class="p">,</span> <span class="n">tmp_excludes</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span>

                <span class="n">new_in_incl</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">valid_includes</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">includes</span><span class="p">])</span>
                <span class="n">out_of_incl</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">includes</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_includes</span><span class="p">])</span>
                <span class="n">new_in_excl</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">valid_excludes</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">excludes</span><span class="p">])</span>
                <span class="n">out_of_excl</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">excludes</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_excludes</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">includes</span> <span class="o">=</span> <span class="n">valid_includes</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">excludes</span> <span class="o">=</span> <span class="n">valid_excludes</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Includes build by </span><span class="si">%s</span><span class="s2">. new: </span><span class="si">%d</span><span class="s2">, removed: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">new_in_incl</span><span class="p">,</span> <span class="n">out_of_incl</span><span class="p">))</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Excludes build by </span><span class="si">%s</span><span class="s2">. new: </span><span class="si">%d</span><span class="s2">, removed: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">new_in_excl</span><span class="p">,</span> <span class="n">out_of_excl</span><span class="p">))</span>

        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Constructed gate with </span><span class="si">%d</span><span class="s2"> including predicates and </span><span class="si">%d</span><span class="s2"> excluding predicates.&quot;</span>
                 <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">includes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">excludes</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">gate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">includes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">excludes</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_inspect_predicates</span><span class="p">(</span><span class="n">includes</span><span class="p">,</span> <span class="n">excludes</span><span class="p">,</span> <span class="n">cls</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">valid_includes</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">includes</span> <span class="k">if</span> <span class="n">is_one_arg_predicate</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>
        <span class="k">except</span> <span class="n">GateCreationException</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GateBuilderException</span><span class="p">(</span><span class="s2">&quot;Invalid include predicate from </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">cls</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">exc</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">valid_excludes</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">excludes</span> <span class="k">if</span> <span class="n">is_one_arg_predicate</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>
        <span class="k">except</span> <span class="n">GateCreationException</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GateBuilderException</span><span class="p">(</span><span class="s2">&quot;Invalid exclude predicate from </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">cls</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">exc</span>

        <span class="k">return</span> <span class="n">valid_includes</span><span class="p">,</span> <span class="n">valid_excludes</span></div>


<div class="viewcode-block" id="GateCreationException"><a class="viewcode-back" href="../../../rst/rspub.util.gates.html#rspub.util.gates.GateCreationException">[docs]</a><span class="k">class</span> <span class="nc">GateCreationException</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :samp:`Indicates a gate could not be created because a given value is not a one-argument predicate`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="GateBuilderException"><a class="viewcode-back" href="../../../rst/rspub.util.gates.html#rspub.util.gates.GateBuilderException">[docs]</a><span class="k">class</span> <span class="nc">GateBuilderException</span><span class="p">(</span><span class="n">GateCreationException</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :samp:`Indicates a gate could not be built because of inappropriate behavior of a GateBuilder`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="n">STOP_ON_CREATION_ERROR</span> <span class="o">=</span> <span class="kc">True</span>


<div class="viewcode-block" id="set_stop_on_creation_error"><a class="viewcode-back" href="../../../rst/rspub.util.gates.html#rspub.util.gates.set_stop_on_creation_error">[docs]</a><span class="k">def</span> <span class="nf">set_stop_on_creation_error</span><span class="p">(</span><span class="n">stop</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :samp:`Determine module-wide behavior on gate creation errors`</span>

<span class="sd">    The function :func:`is_one_arg_predicate` will be called throughout this module by logical functions and</span>
<span class="sd">    gate builder classes in order to detect if a given value is a one-argument predicate.</span>
<span class="sd">    What the behavior of the detecting function will be after detecting a wrong input value can</span>
<span class="sd">    be determined by this method. Either an error message will be logged (stop = **False**) or a</span>
<span class="sd">    :exc:`GateCreationException` will be raised (stop = **True**).</span>

<span class="sd">    :param boolean stop: **True** for stop on creation error, **False** otherwise</span>
<span class="sd">    :return: the previous state</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">STOP_ON_CREATION_ERROR</span>
    <span class="n">previous_value</span> <span class="o">=</span> <span class="n">STOP_ON_CREATION_ERROR</span>
    <span class="n">STOP_ON_CREATION_ERROR</span> <span class="o">=</span> <span class="n">stop</span>
    <span class="k">return</span> <span class="n">previous_value</span></div>


<div class="viewcode-block" id="stop_on_creation_error"><a class="viewcode-back" href="../../../rst/rspub.util.gates.html#rspub.util.gates.stop_on_creation_error">[docs]</a><span class="k">def</span> <span class="nf">stop_on_creation_error</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :samp:`Module-wide behavior on gate creation errors`</span>

<span class="sd">    :return: **True** if stops on creation error, **False** otherwise</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">STOP_ON_CREATION_ERROR</span></div>


<div class="viewcode-block" id="is_one_arg_predicate"><a class="viewcode-back" href="../../../rst/rspub.util.gates.html#rspub.util.gates.is_one_arg_predicate">[docs]</a><span class="k">def</span> <span class="nf">is_one_arg_predicate</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :samp:`Determines if the given {p} is a one-argument predicate`</span>

<span class="sd">    :param p: value to be inspected</span>
<span class="sd">    :return: **True** if `p` is a one-argument predicate, **False** otherwise</span>
<span class="sd">    :raises: :exc:`GateCreationException` if `p` is not a one-argument predicate and :func:`stop_on_creation_error` is **True**</span>

<span class="sd">    .. seealso:: :func:`set_stop_on_creation_error`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_p</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isfunction</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
        <span class="n">is_p</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;not a function: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">p</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">argspec</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getargspec</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">argspec</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">is_p</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;more than one argument in </span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">argspec</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">argspec</span><span class="o">.</span><span class="n">varargs</span><span class="p">:</span>
            <span class="n">is_p</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;varargs in </span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">argspec</span><span class="o">.</span><span class="n">varargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">argspec</span><span class="o">.</span><span class="n">keywords</span><span class="p">:</span>
            <span class="n">is_p</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;keyword arguments in </span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">argspec</span><span class="o">.</span><span class="n">keywords</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_p</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">STOP_ON_CREATION_ERROR</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GateCreationException</span><span class="p">(</span><span class="s2">&quot;Not a one-argument predicate: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Not a one-argument predicate: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">msg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">is_p</span></div>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, DANS-KNAW.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
  
     
    <li><a href="https://github.com/EHRI/rspub-core">rspub-core at GitHub</a></li>


</body>
</html>